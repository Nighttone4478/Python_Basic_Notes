# 🧮 撲克牌梭哈 (題目編號：Q05)

## 📘 題目說明
輸入兩組撲克牌（各 5 張），  
依照題目規則判斷哪一組的牌型較大，並輸出其對應的編號（1～9）。  

若其中一組輸入錯誤（牌面或花色不正確），則輸出 `Error input`；  
若有重複發牌（同一張牌在兩組中重複出現），則輸出 `Duplicate deal`。  


## 📥 輸入說明
- 第 1 行：第一組 5 張撲克牌（以空白分隔）  
- 第 2 行：第二組 5 張撲克牌（以空白分隔）  

## 📤 輸出說明
- 若有輸入錯誤 → `Error input`  
- 若有重複牌 → `Duplicate deal`  
- 否則輸出兩組牌中較大的牌型編號（1～9）


## 📚 範例測資

### ✅ Sample Input 1
```
9D 8C 8S 8H 7C
5H 5D 5C 8S 5S
```
### 🖨️ Sample Output 1
```
Duplicate deal
```

---

### ✅ Sample Input 2
```
5H KC 5C 3D 1D
9D AC 8S 6H 7C
```
### 🖨️ Sample Output 2
```
Error input
```

---

### ✅ Sample Input 3
```
5H 5D 5C 5D 5S
6H KC 5C 3D MZ
```
### 🖨️ Sample Output 3
```
Error input
```

---

### ✅ Sample Input 4
```
5H AS 9C QC 3DD
JC KH 9D 6H 9S
```
### 🖨️ Sample Output 4
```
Error input
```

---

### ✅ Sample Input 5
```
9D 8C 8S 8H 9S
5H 5D 5C 2D 5S
```
### 🖨️ Sample Output 5
```
8
```

---

### ✅ Sample Input 6
```
9D 8C 8S 8H KS
QH KD AC 2D 3S
```
### 🖨️ Sample Output 6
```
5
```

---

### ✅ Sample Input 7
```
10D AD KD QD JD
9D 8C 8S 9H 7C
```
### 🖨️ Sample Output 7
```
9
```

---

### ✅ Sample Input 8
```
AC 3C 9C KC 7C
2D 2H 5C 5H 8D
```
### 🖨️ Sample Output 8
```
6
```


## 🧩 程式邏輯

### 🔹 整體邏輯概述
1️⃣ 定義花色與點數表，用來驗證輸入是否合法。  
2️⃣ 讀取兩組牌：  
　　- 驗證每張牌是否為合法花色與點數。  
　　- 收集所有輸入牌以檢查是否有重複發牌。  
3️⃣ 若任一組輸入錯誤 → 立即輸出 `"Error input"`。  
4️⃣ 若輸入正確但出現重複 → 輸出 `"Duplicate deal"`。  
5️⃣ 否則以函式 `determine()` 判斷每組牌的牌型，輸出最大值。  

---

### 🔹 函式 `iscontinue(points)`
此函式用於**檢查是否為順子（連續數字）**。  

1️⃣ 先將所有點數排序。  
　　例如：`[10, 8, 9, 11, 7] → [7, 8, 9, 10, 11]`。  

2️⃣ 若同時包含 `1(A)` 與 `13(K)`，  
　　表示這是一種「**跨牌型順子**」的可能（例如 A、2、J、Q、K）。  
　　這種情況下，會進入 `while` 迴圈，  
　　不斷將 **最小的數字 +13**，  
　　等於「把 A、2 這類較小的數字往後移動一圈」，  
　　以便讓後續的排序能被同一條判斷式檢查到。  

    例如：[1, 2, 11, 12, 13] → [11, 12, 13, 14, 15]
    這樣就能直接用一個判斷式判斷是否為連續數列。  

3️⃣ 若所有相鄰數字都只差 1 → 為順子（回傳 True），否則 False。  

---

### 🔹 函式 `determine(cards)`
此函式負責**判斷一組牌的牌型強度（1～9）**。  

1️⃣ 將牌分成點數 `number` 與花色 `suit`。  
2️⃣ 檢查各種組合情況，並依照撲克牌規則回傳對應的強度值：  

| 牌型 | 回傳值 | 判斷條件 |
|------|---------|----------|
| 同花順 | 9 | `iscontinue(number)` 為真且花色全相同 |
| 四條 | 8 | 有任意點數出現 4 次 |
| 葫蘆 | 7 | 有 3 張相同 + 2 張相同 |
| 同花 | 6 | 花色全相同但非連號 |
| 順子 | 5 | 點數連續但花色不同 |
| 三條 | 4 | 有任意點數出現 3 次 |
| 兩對 | 3 | 有兩組不同點數，各出現 2 次 |
| 一對 | 2 | 有一組點數出現 2 次 |
| 散牌 | 1 | 以上皆非 |

---

## ✨ 範例程式
~~~python
def card_to_point(card):
    if card == 'A': return 1
    elif card == 'J': return 11
    elif card == 'Q': return 12
    elif card == 'K': return 13
    else: return int(card)

def iscontinue(points):
    points = sorted(points)
    if 1 in points and 13 in points:
        while min(points) < 9:
            points[0] += 13
            points = sorted(points)
    if all(points[i] + 1 == points[i+1] for i in range(len(points)-1)): 
        return True 
    return False

def determine(cards):
    number = []
    suit = []
    for x,y in cards:
        number.append(x)
        suit.append(y)
    
    if iscontinue(number) and len(set(suit)) == 1: return 9
    elif any(number.count(x)==4 for x in number): return 8
    elif any(number.count(x)==3 for x in number) and any(number.count(x)==2 for x in number): return 7
    elif len(set(suit)) == 1: return 6
    elif iscontinue(number): return 5
    elif any(number.count(x)==3 for x in number): return 4
    else :
        tmp = set()
        for x in number:
            if number.count(x) == 2:
                tmp.add(x)
        if len(tmp) == 2: return 3
        elif len(tmp) == 1: return 2
        else: return 1

def main():
    suit_table = {'S','H','D','C'}
    point_table = {'A','2','3','4','5','6','7','8','9','10','J','Q','K'}
    data = []
    isError  = False
    dup_tmp = []

    for _ in range(2):
        cards = input().split()
        dup_tmp += cards
        
        cards = [[x[:-1],x[-1]] for x in cards]

        for card in cards :
            if card[0] not in point_table: isError  = True
            if card[1] not in suit_table: isError  = True
        
        if not isError:
            cards = [[card_to_point(x),y] for x,y in cards]
            data.append(cards)

    if isError : print("Error input") ; return
    elif len(dup_tmp) != len(set(dup_tmp)): print("Duplicate deal") ; return 

    _max = 0

    for d in data:
        _max = max(determine(d),_max) 

    print(_max)
if __name__ == "__main__":
    main()
~~~
