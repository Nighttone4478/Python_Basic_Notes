# 🧮 矩陣操作（題目編號: Q03）
在一個 `N × N` 的方陣中，元素依序為 `1 ~ N^2`（由上到下、由左到右）。  
給定一個操作代號 `D`（1~4），請**不使用任何 List 作為儲存結構**，  
直接以「座標反推」的方式，輸出操作後的矩陣內容。  
每個數字以 `%3d` 的格式印出。

## 📘 題目說明
有四種矩陣操作（對原矩陣進行）：

| D | 操作名稱 | 說明 |
|---|-----------|------|
| 1 | 向左旋轉 90° | 逆時針方向旋轉 |
| 2 | 向右旋轉 90° | 順時針方向旋轉 |
| 3 | 上下翻轉 | 垂直鏡像 |
| 4 | 左右翻轉 | 水平鏡像 |

> ⚠️ 限制：**不能使用 List 或陣列來儲存矩陣**，  
> 所以我們只能透過數學方式「算出每個輸出格子原本是哪個位置」。

## 📥 輸入說明
- 第 1 行輸入整數 `N`（`1 ≤ N ≤ 9`）  
- 第 2 行輸入整數 `D`（`1~4` 其中一個）

## 📤 輸出說明
- 根據 `D` 指令輸出操作後的矩陣。  
- 每個數字以 `%3d` 的格式印出。  
- 每行輸出 `N` 個數字，行尾換行。

## 📚 範例測資

### ✅ Sample Input 1
```
5
1
```
### ✅ Sample Output 1
```
5 10 15 20 25
4  9 14 19 24
3  8 13 18 23
2  7 12 17 22
1  6 11 16 21
```

### ✅ Sample Input 2
```
4
2
```
### ✅ Sample Output 2
```
13  9  5  1
14 10  6  2
15 11  7  3
16 12  8  4
```

### ✅ Sample Input 3
```
3
3
```
### ✅ Sample Output 3
```
7  8  9
4  5  6
1  2  3
```

### ✅ Sample Input 4
```
3
4
```
### ✅ Sample Output 4
```
3  2  1
6  5  4
9  8  7
```

## 🧩 程式邏輯

### 1️⃣ 原矩陣的編號規則
原矩陣第 `r` 列、第 `c` 行的值為：
> `值 = r * N + c + 1`（`r, c` 為 0-based 索引）

### 2️⃣ 座標反推 — 單步操作舉例
由於題目禁止使用 List，我們不能真的「旋轉」矩陣。  
我們要**從結果矩陣的每個位置 `(r_out, c_out)` 出發，去推回它在原矩陣的哪個位置 `(r_in, c_in)`。**

#### 📍例 1：3×3 向左旋轉 90°（D=1）
原矩陣：
```
1  2  3
4  5  6
7  8  9
```
左轉後結果：
```
3  6  9
2  5  8
1  4  7
```
假設輸出矩陣的 `(r_out, c_out) = (0,1)`（值為 6）：
- 左轉反推：`r_in = c_out = 1`、`c_in = N - 1 - r_out = 3 - 1 - 0 = 2`
- 原始位置 `(1,2)` → 值 = 1×3+2+1 = **6**

#### 📍例 2：3×3 上下翻轉（D=3）
原矩陣：
```
1  2  3
4  5  6
7  8  9
```
上下翻後：
```
7  8  9
4  5  6
1  2  3
```
輸出矩陣 `(r_out, c_out) = (0,0)`（值為 7）：
- 上下翻反推：`r_in = N-1-r_out = 2`、`c_in = c_out = 0`
- 原始位置 `(2,0)` → 值 = 2×3+0+1 = **7**

### 3️⃣ 四種操作的反推公式總覽

| D | 操作 | 反推座標（由輸出 → 原矩陣） |
|---|------|----------------------------|
| 1 | 向左轉 90° | `r_in = c_out`，`c_in = N - 1 - r_out` |
| 2 | 向右轉 90° | `r_in = N - 1 - c_out`，`c_in = r_out` |
| 3 | 上下翻轉 | `r_in = N - 1 - r_out`，`c_in = c_out` |
| 4 | 左右翻轉 | `r_in = r_out`，`c_in = N - 1 - c_out` |

### 4️⃣ 主程式流程
1. 讀入 `N` 與 `D`  
2. 使用 `for i in range(N*N)` 逐格輸出  
3. 以 `r, c = divmod(i, N)` 求出輸出座標  
4. 根據 `D` 反推出 `(r_in, c_in)`  
5. 代入公式 `val = r_in * N + c_in + 1`  
6. 以 `%3d` 印出結果  

## ✨ 範例程式
~~~python
def transfrom(r, c, D, N):
    if D == 1:
        r, c = c, r
        r, c = r, N - c - 1
    elif D == 2:
        r, c = c, r
        r, c = N - r - 1, c
    elif D == 3:
        r, c = N - r - 1, c
    elif D == 4:
        r, c = r, N - c - 1
    return r * N + c + 1

def main():
    N = int(input().strip())
    D = int(input().strip())
    for i in range(N * N):
        r, c = divmod(i, N)
        val = transfrom(r, c, D, N)
        print("%3d" % val, end="")
        if (i + 1) % N == 0:
            print()

if __name__ == "__main__":
    main()
~~~

## 🚀 延伸應用：多層操作（複合轉換）

若操作序列包含多步（例如 `214` 或 `LVR`），  
必須**反向依序反推**，因為我們是「從輸出回推到原始座標」。

### 📘 多層操作反推示意

**情境**：`N = 3`，操作序列為 `D = 2 → 3`（先**右轉 90°**，再**上下翻**）。  
我們要找出**輸出矩陣**中 `(r_out, c_out) = (0, 0)` 這一格，對應到**原矩陣**的哪一格。

**步驟 1 — 明確寫出「反推順序」與每步公式**  
- 原始操作順序：右轉(2) → 上下翻(3)  
- 反推時順序要顛倒：**先還原上下翻(3)，再還原右轉(2)**  
- 反推公式：  
  - 上下翻(3)：`r' = N-1 - r`，`c' = c`  
  - 右轉(2)   ：`r'' = N-1 - c'`，`c'' = r'`

**步驟 2 — 代入輸出座標，先「還原上下翻(3)」**  
- 已知 `(r_out, c_out) = (0, 0)`  
- 套用上下翻反推：  
  - `r1 = N-1 - r_out = 2`  
  - `c1 = c_out = 0`  
- 得到中繼座標：`(r1, c1) = (2, 0)`

**步驟 3 — 再「還原右轉(2)」**  
- 以上一步的 `(r1, c1)` 當作輸入：  
  - `r_in = N-1 - c1 = 2`  
  - `c_in = r1 = 2`  
- 得到原矩陣座標：`(r_in, c_in) = (2, 2)`

**步驟 4 — 由原矩陣座標得到實際數值**  
- 使用編號公式 `val = r_in * N + c_in + 1`：  
  - `val = 2 * 3 + 2 + 1 = 9`  
- 所以輸出矩陣的 `(0,0)` 其實來自原矩陣的數值 **9**。

**步驟 5 — 交叉驗證**  
- 先對原矩陣右轉，再上下翻，觀察 `9` 的位置確實會來到 `(0,0)`。  
- 這個驗證步驟能幫助你在考試/上機時快速檢查坐標反推是否正確。

### ✨ 多層操作完整程式
~~~python
def step_inverse(r, c, cmd, N):
    if cmd in ("1", "L"):
        r, c = c, r
        r, c = r, N - c - 1
    elif cmd in ("2", "R"):
        r, c = c, r
        r, c = N - r - 1, c
    elif cmd in ("3", "V"):
        r, c = N - r - 1, c
    elif cmd in ("4", "H"):
        r, c = r, N - c - 1
    return r, c

def transfrom_multi(r, c, seq, N):
    for cmd in reversed(seq):
        r, c = step_inverse(r, c, cmd, N)
    return r * N + c + 1

def main():
    N = int(input().strip())
    seq = input().strip()
    for i in range(N * N):
        r, c = divmod(i, N)
        val = transfrom_multi(r, c, seq, N)
        print("%3d" % val, end="")
        if (i + 1) % N == 0:
            print()

if __name__ == "__main__":
    main()
~~~

### 🧠 重點整理
| 主題 | 說明 |
|------|------|
| 單步操作 | 直接用對應的反推公式 |
| 多層操作 | 將操作序列反向逐步反推 |
| 不可使用 | List、暫存矩陣、陣列搬移 |
| 完成條件 | 只需座標計算即可輸出所有結果 |
